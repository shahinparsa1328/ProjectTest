
import React from 'react'; // Ensure React is imported for React.ReactElement

export interface LearningCategory {
  id: string;
  name: string;
  icon?: React.ReactElement<{ className?: string }>; 
  description?: string;
}

export interface GoalRelevanceFilter {
  id: string;
  name: string; 
  description?: string;
}


export interface QuizQuestionOption {
  id: string;
  text: string;
}

export interface QuizQuestion {
  id: string;
  questionText: string;
  options: QuizQuestionOption[];
  correctOptionId: string;
  explanation?: string;
  incorrectAnswerFeedback?: { [optionId: string]: { explanation: string; reviewLink?: string; reviewLinkText?: string; } };
  points?: number; 
}

export type Quiz = QuizQuestion[];


export interface LearningModule {
  id: string;
  title: string;
  description: string;
  estimatedTime?: string;
  contentIds: string[]; // IDs of LearningContent items
  progress: number; // 0-100
  completed: boolean;
  quiz?: Quiz;
  exerciseId?: string; // ID of a PracticalExercise
  isAISuggested?: boolean;
  isSkippable?: boolean;
  aiSuggestionRationale?: string;
  points?: number; // Points awarded for completing this module
}

export interface LearningPath {
  id: string;
  title: string;
  description: string;
  categoryIds: string[];
  goalRelevanceIds?: string[];
  learningObjectives: string[];
  prerequisites?: string[];
  modules: LearningModule[];
  estimatedTime: string;
  difficultyLevel: 'Beginner' | 'Intermediate' | 'Advanced';
  thumbnailUrl?: string;
  overallProgress: number; // Calculated based on module progress
  isAIGenerated?: boolean; // True if path was suggested/generated by AI
  aiGenerationRationale?: string; // Explanation if AI generated
}


export type LearningContentType = 'article' | 'video' | 'infographic' | 'quiz' | 'interactive_simulation' | 'course';

export interface LearningContent {
  id: string;
  title: string;
  type: LearningContentType;
  categoryIds: string[];
  goalRelevanceIds?: string[];
  contentUrl?: string;
  description: string;
  tags: string[];
  estimatedTime: string;
  difficultyLevel: 'Easy' | 'Medium' | 'Hard' | 'Advanced';
  thumbnailUrl?: string;
  author?: string;
  publishDate?: string;
  quiz?: Quiz; // Re-using Quiz type
  aiRationale?: string; // Why AI suggested this content
  contentKeyForReview?: string; // If content needs review
  isUGC?: boolean; // If content is user-generated
}

export interface Badge {
  id: string;
  name: string;
  iconUrl?: string | React.ReactElement<{className?: string}>; 
  description: string;
  earnedDate?: string; // ISO string if earned
  condition?: string; // Condition to earn the badge (for unearned badges)
  pointsRequired?: number; // Points threshold if badge is tied to points
  specificAchievement?: string; // e.g., "Completed 'Advanced Python' path"
}

export interface Skill {
  id: string;
  name: string;
  proficiency: 'learning' | 'acquired' | 'suggested_ai' | 'mastered'; 
  categoryName?: string; 
  relatedPathIds?: string[];
  relatedExerciseIds?: string[];
  assessmentScore?: number; 
}

export interface PeerReviewCriterion {
  id: string;
  text: string; 
  description?: string; 
}
export interface PeerReview {
  id: string;
  exerciseId: string; 
  reviewerId: string; 
  revieweeId: string; 
  criteriaRatings: { criterionId: string; rating: number; comment?: string }[]; 
  overallFeedback: string;
  isAnonymous: boolean;
  submissionDate: string; 
  feedbackQualityRating?: number; 
}

export interface PracticalExercise {
  id: string;
  title: string;
  description: string;
  submissionType: 'text' | 'file' | 'link'; 
  skillToPractice: string; 
  aiFeedbackCriteria?: string[]; 
  evaluationCriteria?: PeerReviewCriterion[]; 
  submissionText?: string; 
  submissionFileUrl?: string;
  submissionLink?: string;
  aiFeedback?: string; 
  peerReviewsRequested?: boolean;
  peerReviewsReceived?: PeerReview[];
  status?: 'not_started' | 'in_progress' | 'submitted' | 'feedback_received' | 'completed';
  points?: number;
}

export interface JournalEntry {
  id: string;
  date: string; // ISO string
  title?: string;
  text: string;
  tags?: string[];
  aiInsight?: string; 
  relatedLearningContentId?: string; 
}

export interface WeeklyChallenge {
  id: string;
  title: string;
  description: string;
  skillApplied: string; 
  dueDate: string; // ISO string
  rewardPoints?: number;
  status: 'active' | 'completed' | 'expired';
}

export interface AILearningBuddyMessage {
  id: string;
  text: string;
  sender: 'user' | 'ai';
  timestamp: number; // Unix timestamp
  quickReplies?: { text: string; payload: string }[];
  isFeedbackRequest?: boolean; 
  relatedContentId?: string; 
}

export interface UserProgress {
  points: number;
  level: 'Novice' | 'Explorer' | 'Skilled' | 'Master' | 'Legend' | 'Guru'; 
  levelNamePersian: string;
  dailyStreak?: number;
  weeklyXP?: number;
}

export interface ForumTopic { 
  id: string;
  title: string;
  author: string; 
  lastActivity: string; 
  repliesCount: number;
  viewCount: number;
  tags?: string[];
  isPinned?: boolean;
  relatedLearningPathId?: string; 
}

export interface StudyGroup { 
  id: string;
  name: string;
  topic: string; 
  membersCount: number;
  isActive: boolean;
  thumbnailUrl?: string;
  description?: string;
  relatedLearningPathId?: string;
}

export interface Webinar { 
  id: string;
  title: string;
  speaker: string;
  dateTime: string; 
  duration: string; 
  platform: string; 
  isLive?: boolean;
  registrationLink?: string;
  description?: string;
  relatedSkillId?: string;
}

export interface LearningSuggestion {
  id: string;
  type: 'path' | 'content' | 'exercise' | 'challenge'; 
  itemId: string; 
  title: string; 
  description?: string; 
  sourceModule: 'Goals' | 'Tasks' | 'Health' | 'Finance' | 'LifeProjects' | 'Learning' | 'SmartHome' | 'Community'; 
  triggerContext: string; 
  relevanceScore?: number; 
}

export interface KeyResult { 
  id: string;
  text: string;
  progress: number; 
  targetValue?: number;
  currentValue?: number;
  unit?: string;
}

export interface GoalActionPlanTask {
  id: string; 
  title: string;
  dueDate?: string; 
  description?: string;
  completed: boolean;
  estimatedDurationMinutes?: number;
}

export interface Goal {
  id: string;
  title: string;
  description?: string;
  dueDate?: string; 
  category?: string;
  progress: number; 
  status: 'active' | 'paused' | 'completed' | 'planning';
  smartGoalTitle?: string; 
  smartGoalDescription?: string; 
  aiRationale?: string; 
  actionPlanTasks?: GoalActionPlanTask[]; 
  aiActionPlanSummary?: string; 
  aiNextStep?: string; 
  aiNextStepRationale?: string; 
  learningSuggestions?: LearningSuggestion[];
  lifeProjectId?: string; 
  keyResults?: KeyResult[]; 
}

export interface Task {
  id: string;
  title: string;
  description?: string;
  priority: 'high' | 'medium' | 'low';
  dueDate?: string; 
  tags?: string[];
  context?: string;
  relatedGoalId?: string;
  completed: boolean;
  subTasks: Task[]; 
  aiConfidence?: number; 
  rawInput?: string; 
  isAiExtracted?: boolean; 
  isDifficult?: boolean; 
  reflectionCompleted?: boolean; 
  learningSuggestions?: LearningSuggestion[];
  lifeProjectId?: string; 
  aiSuggestedOrder?: number; 
  estimatedDurationMinutes?: number;
}

export interface LifeProjectTask {
  id: string;
  projectId: string; 
  title: string;
  description?: string;
  status: 'pending' | 'in_progress' | 'completed';
  dueDate?: string; 
  assignedTo?: string; 
  order?: number; 
  originalTaskId?: string; 
  estimatedDurationMinutes?: number;
}

export interface LifeProject {
  id: string;
  title: string;
  description: string;
  relatedGoalIds: string[]; 
  requiredSkillIds?: string[]; 
  learningPathSuggestions?: LearningSuggestion[];
  overallProgress: number; 
  status: 'planning' | 'active' | 'completed' | 'on_hold';
  coverImageUrl?: string;
  startDate?: string; 
  endDate?: string;   
  aiGeneratedInsights?: string[]; 
  tasks?: LifeProjectTask[]; 
}


export interface AI360FeedbackItem {
  id: string;
  date: string; 
  feedbackText: string;
  relatedContext: string; 
  type: 'positive' | 'constructive' | 'observation' | 'question'; 
  actionableSuggestion?: string; 
}

export interface ConversationScenario {
  id: string;
  title: string;
  description: string;
  aiRoleDescription: string; 
  initialPrompt: string; 
  userObjective: string; 
  keyConceptsToPractice?: string[];
  feedbackMetrics?: { 
    clarity?: boolean;
    persuasiveness?: boolean;
    empathy?: boolean;
    problemSolving?: boolean;
    custom?: string[]; 
  };
}

export interface SimulationSessionReport {
  sessionId: string;
  scenarioId: string;
  date: string; 
  userPerformanceSummary: string;
  strengths: string[];
  areasForImprovement: string[];
  specificSuggestions: string[];
}

export type BrainstormingTechnique = 'SCAMPER' | 'SixThinkingHats' | 'MindMapping' | 'GeneralBrainstorm' | 'ReverseBrainstorming' | 'SWOT';

export interface CreativeIdea {
  id: string;
  text: string;
  color?: string; 
  position?: { x: number; y: number }; 
  parentId?: string | null; 
  techniqueUsed?: BrainstormingTechnique;
  isAIReply?: boolean; 
  details?: Record<string, any>; 
  aiGeneratedVisualConcept?: string; 
}

export interface MentorshipProfile { 
  userId: string; 
  userName: string;
  skillsToMentor: string[]; 
  experienceLevel: string; 
  availability: string; 
  bio?: string;
  profileImageUrl?: string;
  menteeCount?: number;
  averageRating?: number;
}

export interface MentorshipRequest { 
  id: string;
  menteeId: string;
  mentorId: string;
  message: string;
  requestedSkill: string;
  status: 'pending' | 'accepted' | 'declined' | 'completed';
  requestDate: string; 
}

export interface UserGeneratedContent { 
  id: string;
  authorId: string;
  authorName: string;
  type: 'path' | 'article' | 'resource_link' | 'quiz' | 'exercise'; 
  title: string;
  description: string;
  contentData: any; 
  tags: string[];
  submissionDate: string; 
  status: 'pending_approval' | 'approved' | 'rejected'; 
  averageRating?: number;
  reviewCount?: number;
}

export interface PredictiveSkillSuggestion {
  id: string;
  skillName: string;
  rationale: string; 
  relevanceToUser?: string; 
  learningPathId?: string; 
  marketDemandIndicator?: 'high' | 'medium' | 'low' | 'emerging'; 
  confidenceScore?: number; 
}

export interface LearningReportConfig {
  period: 'monthly' | 'quarterly' | 'annually';
  includeSkillSummary: boolean;
  includeGoalImpactAnalysis: boolean;
  includeFutureSuggestions: boolean;
  includeStrengthsWeaknesses?: boolean; 
  format: 'html' | 'markdown' | 'pdf_summary'; 
}

// --- HABIT ENGINEERING TYPES ---
export type HabitQuality = 'excellent' | 'good' | 'fair' | 'poor' | 'not_tracked';
export type HabitEmotion = 'energized' | 'happy' | 'neutral' | 'tired' | 'stressed' | 'other';

export interface HabitLogEntry {
  id: string;
  date: string; // ISO YYYY-MM-DD
  completed: boolean;
  quality?: HabitQuality;
  durationMinutes?: number;
  context?: string;
  emotionBefore?: HabitEmotion;
  emotionAfter?: HabitEmotion;
  notes?: string;
}

export interface AdaptiveReminderSettings {
  enabled: boolean;
  // More complex settings can be added later, e.g.:
  // preferredWindows: { start: string; end: string; days: DayOfWeek[] }[]; // e.g., "07:00"-"09:00" on weekdays
  // contextualTriggers: ('after_waking_up' | 'before_work' | 'after_meal' | 'location_change_home')[];
}

export interface Habit {
  id: string;
  title: string;
  description?: string;
  frequency: 'daily' | 'weekly' | 'custom'; 
  customFrequencyDetails?: { 
    daysOfWeek?: ('Sat' | 'Sun' | 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri')[];
    timesPerWeek?: number; 
  };
  timeOfDay: 'morning' | 'afternoon' | 'evening' | 'any' | string; 
  
  // Multidimensional Tracking
  log: HabitLogEntry[];
  defaultQualityTrack?: boolean; 
  defaultDurationTrack?: boolean; 
  defaultContextTrack?: boolean;
  defaultEmotionTrack?: boolean;

  // Gamification
  streak: number;
  level?: number;
  xp?: number;
  rewardPointsEarned?: number;
  badgesEarned?: string[]; 

  // AI & Reminders
  relatedGoalId?: string;
  contextTrigger?: string; 
  atomicSuggestion?: string; 
  isAISuggested?: boolean;
  aiSuggestionId?: string; 
  aiRationale?: string;
  reminderSettings?: AdaptiveReminderSettings;
  nextSmartReminder?: string; 
  lastCompletedDate?: string; 
}

export interface HabitSuggestionDetails {
  title: string;
  description: string;
  aiRationale: string;
  frequency: 'daily' | 'weekly' | 'custom' | string; 
  timeOfDay?: Habit['timeOfDay']; 
  potentialBenefits?: string[];
}
```
    </content>
  </change>
  <change>
    <file>components/pages/HabitsPage.tsx</file>
    <description>Implement advanced habit engineering features: AI habit suggestions, adaptive gamification (streak, XP, level), multidimensional tracking (quality, duration, context, emotions via logging modal), and conceptual hyper-adaptive AI reminders using Gemini. Add/Edit habit form integrated within page state. Add localStorage persistence.</description>
    <content><![CDATA[
import React, { useState, useCallback, useEffect, useRef } from 'react';
import { toPersianDigits, parseJsonFromString } from '../../utils';
import { 
  RepeatIcon as PageIcon, 
  PlusIcon, 
  SparklesIconNav as AiIcon, 
  MicrophoneIcon, 
  CameraIcon, 
  CheckCircleIcon, 
  XCircleIcon, 
  LightbulbIcon, 
  TrashIcon, 
  PencilIcon, 
  ClockIcon,
  FireIcon,
  StarIcon,
  TrophyIcon,
  ChevronDownIcon,
  ChevronUpIcon,
  BellIcon
} from '../shared/AppIcons';
import LoadingSpinner from '../shared/LoadingSpinner';
import { GoogleGenAI, GenerateContentResponse } from "@google/genai";
import XAIModal from '../shared/XAIModal';
import ToastNotification from '../shared/ToastNotification';
import CollapsibleSection from '../shared/CollapsibleSection';
import { Habit, HabitLogEntry, HabitQuality, HabitEmotion, HabitSuggestionDetails } from '../../types/learningTypes';

export interface HabitsPageProps { 
  openAddGoalModal?: () => void; 
}

const AI_MODEL_NAME = 'gemini-2.5-flash-preview-04-17';
const HABITS_LOCAL_STORAGE_KEY = 'lifeOrchestrator_habitsData_v3'; 

interface AddHabitModalState {
  isOpen: boolean;
  editingHabit: Habit | null;
  title: string;
  description: string;
  frequency: Habit['frequency'];
  daysOfWeek: Array<NonNullable<NonNullable<Habit['customFrequencyDetails']>['daysOfWeek']>[0]>; 
  timeOfDay: Habit['timeOfDay'];
  contextTrigger: string;
  relatedGoalId: string;
}

interface LogHabitModalState {
  isOpen: boolean;
  habitToLog: Habit | null;
  logDate: string; 
  completed: boolean;
  quality: HabitQuality;
  durationMinutes: string;
  context: string;
  emotionBefore: HabitEmotion;
  emotionAfter: HabitEmotion;
  notes: string;
}

const defaultAddHabitModalState: AddHabitModalState = {
  isOpen: false, editingHabit: null, title: '', description: '', frequency: 'daily', 
  daysOfWeek: [], timeOfDay: 'any', contextTrigger: '', relatedGoalId: ''
};

const defaultLogHabitModalState: LogHabitModalState = {
  isOpen: false, habitToLog: null, logDate: new Date().toISOString().split('T')[0], completed: true, quality: 'not_tracked', 
  durationMinutes: '', context: '', emotionBefore: 'neutral', emotionAfter: 'neutral', notes: ''
};

const emotionOptions: { value: HabitEmotion; label: string; emoji: string }[] = [
  { value: 'energized', label: 'Ù¾Ø±Ø§Ù†Ø±Ú˜ÛŒ', emoji: 'âš¡ï¸' }, { value: 'happy', label: 'Ø®ÙˆØ´Ø­Ø§Ù„', emoji: 'ğŸ˜Š' },
  { value: 'neutral', label: 'Ø®Ù†Ø«ÛŒ', emoji: 'ğŸ˜' }, { value: 'tired', label: 'Ø®Ø³ØªÙ‡', emoji: 'ğŸ˜©' },
  { value: 'stressed', label: 'Ù¾Ø±Ø§Ø³ØªØ±Ø³', emoji: 'ğŸ˜¥' }, { value: 'other', label: 'Ø³Ø§ÛŒØ±', emoji: 'â“' },
];
const qualityOptions: { value: HabitQuality; label: string; color: string }[] = [
  { value: 'excellent', label: 'Ø¹Ø§Ù„ÛŒ', color: 'text-green-600' }, { value: 'good', label: 'Ø®ÙˆØ¨', color: 'text-sky-600' },
  { value: 'fair', label: 'Ù…ØªÙˆØ³Ø·', color: 'text-yellow-600' }, { value: 'poor', label: 'Ø¶Ø¹ÛŒÙ', color: 'text-red-600' },
  { value: 'not_tracked', label: 'Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡', color: 'text-gray-500' },
];


const HabitsPage: React.FC<HabitsPageProps> = ({ openAddGoalModal }) => {
  const [habits, setHabits] = useState<Habit[]>([]);
  const [addHabitModal, setAddHabitModal] = useState<AddHabitModalState>(defaultAddHabitModalState);
  const [logHabitModal, setLogHabitModal] = useState<LogHabitModalState>(defaultLogHabitModalState);

  const [aiHabitSuggestions, setAiHabitSuggestions] = useState<HabitSuggestionDetails[]>([]);
  const [isLoadingAiSuggestions, setIsLoadingAiSuggestions] = useState(false);
  const [aiSuggestionError, setAiSuggestionError] = useState<string | null>(null);
  const [userHabitContext, setUserHabitContext] = useState(localStorage.getItem('userHabitContext_v1') || '');


  const [toast, setToast] = useState<{id: number, text: string, type: 'success'|'error'|'info'} | null>(null);
  
  const ai = process.env.API_KEY ? new GoogleGenAI({ apiKey: process.env.API_KEY }) : null;

  const showToast = useCallback((text: string, type: 'success'|'error'|'info' = 'info') => {
    setToast({ id: Date.now(), text: toPersianDigits(text), type });
  }, []);

  useEffect(() => { if (toast) { const timer = setTimeout(() => setToast(null), 3000); return () => clearTimeout(timer); }}, [toast]);
  useEffect(() => { localStorage.setItem(HABITS_LOCAL_STORAGE_KEY, JSON.stringify(habits)); }, [habits]);
  useEffect(() => { localStorage.setItem('userHabitContext_v1', userHabitContext); }, [userHabitContext]);


  useEffect(() => {
    try {
        const storedHabits = localStorage.getItem(HABITS_LOCAL_STORAGE_KEY);
        if (storedHabits) { setHabits(JSON.parse(storedHabits)); } 
        else { setHabits([ { id: 'habit1', title: 'Ù†ÙˆØ´ÛŒØ¯Ù† Û¸ Ù„ÛŒÙˆØ§Ù† Ø¢Ø¨', frequency: 'daily', timeOfDay: 'any', streak: 5, log: [], level: 2, xp: 150, lastCompletedDate: new Date(Date.now() - 86400000).toISOString().split('T')[0], reminderSettings: {enabled: true}, defaultQualityTrack: true }, { id: 'habit2', title: 'Û³Û° Ø¯Ù‚ÛŒÙ‚Ù‡ Ù…Ø·Ø§Ù„Ø¹Ù‡ Ù‚Ø¨Ù„ Ø§Ø² Ø®ÙˆØ§Ø¨', frequency: 'daily', timeOfDay: 'evening', streak: 12, log: [], level: 3, xp: 320, lastCompletedDate: new Date(Date.now() - 86400000 * 2).toISOString().split('T')[0], reminderSettings: {enabled: false}, defaultContextTrack: true, defaultEmotionTrack: true }, ]); }
    } catch (error) { console.error("Error loading habits:", error); showToast("Ø®Ø·Ø§ Ø¯Ø± Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ Ø¹Ø§Ø¯Ø§Øª.", "error"); }
  }, [showToast]);


  const handleOpenAddHabitModal = (habitToEdit: Habit | null = null) => { 
      if (habitToEdit) {
      setAddHabitModal({
        isOpen: true, editingHabit: habitToEdit, title: habitToEdit.title, description: habitToEdit.description || '',
        frequency: habitToEdit.frequency, daysOfWeek: habitToEdit.customFrequencyDetails?.daysOfWeek || [],
        timeOfDay: habitToEdit.timeOfDay, contextTrigger: habitToEdit.contextTrigger || '', relatedGoalId: habitToEdit.relatedGoalId || ''
      });
    } else {
      setAddHabitModal({ ...defaultAddHabitModalState, isOpen: true });
    }
  };
  const handleSaveHabit = () => { 
    const { editingHabit, title, description, frequency, daysOfWeek, timeOfDay, contextTrigger, relatedGoalId } = addHabitModal;
    if (!title.trim()) { showToast("Ø¹Ù†ÙˆØ§Ù† Ø¹Ø§Ø¯Øª Ø§Ù„Ø²Ø§Ù…ÛŒ Ø§Ø³Øª.", "error"); return; }

    const habitData = {
      title: title.trim(), description: description.trim() || undefined, frequency,
      customFrequencyDetails: (frequency === 'weekly' || frequency === 'custom') ? { daysOfWeek } : undefined,
      timeOfDay, contextTrigger: contextTrigger.trim() || undefined, relatedGoalId: relatedGoalId.trim() || undefined
    };

    if (editingHabit) {
      setHabits(prev => prev.map(h => h.id === editingHabit.id ? { ...editingHabit, ...habitData } : h));
      showToast("Ø¹Ø§Ø¯Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ÙˆÛŒØ±Ø§ÛŒØ´ Ø´Ø¯.", "success");
    } else {
      const newHabit: Habit = {
        id: `habit-${Date.now()}`, ...habitData, streak: 0, log: [], level: 1, xp: 0, reminderSettings: {enabled: true}
      };
      setHabits(prev => [newHabit, ...prev]);
      showToast("Ø¹Ø§Ø¯Øª Ø¬Ø¯ÛŒØ¯ Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.", "success");
    }
    setAddHabitModal(defaultAddHabitModalState);
   };
  const handleDeleteHabit = (habitId: string) => { 
    if (window.confirm(toPersianDigits("Ø¢ÛŒØ§ Ø§Ø² Ø­Ø°Ù Ø§ÛŒÙ† Ø¹Ø§Ø¯Øª Ù…Ø·Ù…Ø¦Ù† Ù‡Ø³ØªÛŒØ¯ØŸ"))) {
      setHabits(prev => prev.filter(h => h.id !== habitId));
      showToast("Ø¹Ø§Ø¯Øª Ø­Ø°Ù Ø´Ø¯.", "info");
    }
  };
  const handleOpenLogHabitModal = (habit: Habit, completedStatus: boolean = true) => { 
    const todayStr = new Date().toISOString().split('T')[0];
    const existingLog = habit.log.find(l => l.date === todayStr);
    if (existingLog) {
        setLogHabitModal({
            isOpen: true, habitToLog: habit, logDate: todayStr,
            completed: existingLog.completed, quality: existingLog.quality || 'not_tracked',
            durationMinutes: existingLog.durationMinutes?.toString() || '',
            context: existingLog.context || '', emotionBefore: existingLog.emotionBefore || 'neutral',
            emotionAfter: existingLog.emotionAfter || 'neutral', notes: existingLog.notes || ''
        });
    } else {
        setLogHabitModal({ ...defaultLogHabitModalState, isOpen: true, habitToLog: habit, completed: completedStatus, logDate: todayStr });
    }
  };

  const handleSaveHabitLog = () => {
    const { habitToLog, logDate, completed, quality, durationMinutes, context, emotionBefore, emotionAfter, notes } = logHabitModal;
    if (!habitToLog) return;

    const newLogEntry: HabitLogEntry = {
      id: `log-${Date.now()}`, date: logDate, completed,
      quality: quality === 'not_tracked' ? undefined : quality,
      durationMinutes: durationMinutes ? parseInt(durationMinutes) : undefined,
      context: context.trim() || undefined,
      emotionBefore: emotionBefore === 'other' || emotionBefore === 'neutral' ? undefined : emotionBefore,
      emotionAfter: emotionAfter === 'other' || emotionAfter === 'neutral' ? undefined : emotionAfter,
      notes: notes.trim() || undefined,
    };

    setHabits(prevHabits => prevHabits.map(h => {
      if (h.id === habitToLog.id) {
        const updatedLog = h.log.filter(l => l.date !== logDate).concat(newLogEntry).sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime());
        
        let newStreak = h.streak;
        let newXp = h.xp || 0;
        let newLevel = h.level || 1;
        let newLastCompletedDate = h.lastCompletedDate;

        if(completed) {
            const today = new Date(logDate);
            const lastCompleted = h.lastCompletedDate ? new Date(h.lastCompletedDate) : null;
            if (lastCompleted && (today.getTime() - lastCompleted.getTime()) <= 2 * 86400000 && (today.getTime() - lastCompleted.getTime()) > 0) { 
                 newStreak = (today.getTime() - lastCompleted.getTime()) / 86400000 === 1 ? h.streak + 1 : h.streak; 
            } else if (!lastCompleted || (today.getTime() - lastCompleted.getTime()) / 86400000 > 1) {
                 newStreak = 1; 
            } 
            
            newXp += 10 + (newStreak * 2); 
            if (quality === 'excellent') newXp += 5;
            if (quality === 'good') newXp += 2;
            
            while (newXp >= (newLevel * 100)) { 
                newXp -= (newLevel * 100);
                newLevel += 1;
                showToast(toPersianDigits(`Ø¹Ø§Ø¯Øª "${h.title}" Ø¨Ù‡ Ø³Ø·Ø­ ${String(newLevel)} Ø§Ø±ØªÙ‚Ø§ ÛŒØ§ÙØª!`), 'success');
            }
            newLastCompletedDate = logDate;
        } else { 
            if (h.lastCompletedDate === logDate) {
                const sortedLogs = updatedLog.filter(l => l.completed).sort((a,b) => new Date(b.date).getTime() - new Date(a.date).getTime());
                if (sortedLogs.length > 0) {
                    newLastCompletedDate = sortedLogs[0].date;
                    newStreak = 1; 
                    for(let i = 0; i < sortedLogs.length - 1; i++){
                        if((new Date(sortedLogs[i].date).getTime() - new Date(sortedLogs[i+1].date).getTime()) / 86400000 === 1){
                            newStreak++;
                        } else {
                            break;
                        }
                    }
                } else {
                    newLastCompletedDate = undefined;
                    newStreak = 0;
                }
            }
            newXp = Math.max(0, newXp - 10); 
        }
        return { ...h, log: updatedLog, streak: newStreak, xp: newXp, level: newLevel, lastCompletedDate: newLastCompletedDate };
      }
      return h;
    }));
    setLogHabitModal(defaultLogHabitModalState);
    showToast("Ú¯Ø²Ø§Ø±Ø´ Ø¹Ø§Ø¯Øª Ø«Ø¨Øª Ø´Ø¯.", "success");
  };

  const fetchAIHabitSuggestions = async () => {
    if (!ai) { setAiSuggestionError(toPersianDigits("Ø³Ø±ÙˆÛŒØ³ Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª.")); return; }
    setIsLoadingAiSuggestions(true); setAiSuggestionError(null);
    try {
      const prompt = `Ø¨Ø± Ø§Ø³Ø§Ø³ Ø²Ù…ÛŒÙ†Ù‡ Ú©Ø§Ø±Ø¨Ø±: "${userHabitContext || 'Ø¨Ù‡Ø¨ÙˆØ¯ Ú©Ù„ÛŒ Ø²Ù†Ø¯Ú¯ÛŒ'}", Û² ØªØ§ Û³ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¹Ø§Ø¯Øª Ø¬Ø¯ÛŒØ¯ Ø¨Ù‡ Ø²Ø¨Ø§Ù† ÙØ§Ø±Ø³ÛŒ Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ø¯Ù‡. Ù‡Ø± Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¨Ø§ÛŒØ¯ Ø´Ø§Ù…Ù„ "title", "description" (ØªÙˆØ¶ÛŒØ­ Ú©ÙˆØªØ§Ù‡ Ú†Ø±Ø§ Ø§ÛŒÙ† Ø¹Ø§Ø¯Øª Ù…ÙÛŒØ¯ Ø§Ø³Øª), "aiRationale" (Ù…Ù†Ø·Ù‚ Ø¯Ù‚ÛŒÙ‚â€ŒØªØ± Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯), "frequency" (Ù…Ø§Ù†Ù†Ø¯ 'daily', '3 times a week') Ùˆ "timeOfDay" (Ù…Ø§Ù†Ù†Ø¯ 'morning', 'any') Ø¨Ø§Ø´Ø¯. Ù¾Ø§Ø³Ø® Ø±Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø¢Ø±Ø§ÛŒÙ‡ JSON Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ø¯Ù‡.`;
      const response: GenerateContentResponse = await ai.models.generateContent({ model: AI_MODEL_NAME, contents: prompt, config: { responseMimeType: "application/json" } });
      const parsedData = parseJsonFromString<HabitSuggestionDetails[]>(response.text);
      if (parsedData && Array.isArray(parsedData)) { setAiHabitSuggestions(parsedData); } 
      else { throw new Error("Failed to parse AI suggestions."); }
    } catch (e: any) { setAiSuggestionError(toPersianDigits(`Ø®Ø·Ø§ Ø¯Ø± Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª: ${e.message || "Ù„Ø·ÙØ§ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†ÛŒØ¯."}`)); } 
    finally { setIsLoadingAiSuggestions(false); }
  };
  
  const handleAcceptAISuggestion = (suggestion: HabitSuggestionDetails) => { 
    const newHabit: Habit = {
        id: `habit-ai-${Date.now()}`,
        title: suggestion.title,
        description: suggestion.description,
        frequency: suggestion.frequency.toLowerCase().includes("daily") ? 'daily' : suggestion.frequency.toLowerCase().includes("weekly") ? 'weekly' : 'custom',
        customFrequencyDetails: (suggestion.frequency.toLowerCase().includes("weekly") || suggestion.frequency.toLowerCase().includes("custom")) ? { daysOfWeek: [], timesPerWeek: parseInt(suggestion.frequency) || undefined } : undefined,
        timeOfDay: suggestion.timeOfDay || 'any',
        streak: 0,
        log: [],
        level: 1,
        xp: 0,
        isAISuggested: true,
        aiRationale: suggestion.aiRationale,
        reminderSettings: { enabled: true }
    };
    setHabits(prev => [newHabit, ...prev]);
    setAiHabitSuggestions(prev => prev.filter(s => s.title !== suggestion.title)); 
    showToast(toPersianDigits(`Ø¹Ø§Ø¯Øª "${suggestion.title}" Ø§Ø¶Ø§ÙÙ‡ Ø´Ø¯.`), "success");
  };
  
  const getAIWellnessReminder = async (habit: Habit): Promise<string | null> => { 
    if (!ai) return null;
    const currentTime = new Date().toLocaleTimeString('fa-IR', { hour: '2-digit', minute: '2-digit'});
    const userActivity = "Ø¯Ø± Ø­Ø§Ù„ Ú©Ø§Ø± Ø¨Ø§ Ú©Ø§Ù…Ù¾ÛŒÙˆØªØ±"; 
    const prompt = `Ú©Ø§Ø±Ø¨Ø± Ø¹Ø§Ø¯Øª "${habit.title}" Ø±Ø§ Ø¯Ø§Ø±Ø¯ Ú©Ù‡ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø¯Ø± "${habit.timeOfDay}" Ø§Ù†Ø¬Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯. Ø§Ú©Ù†ÙˆÙ† Ø³Ø§Ø¹Øª ${currentTime} Ø§Ø³Øª Ùˆ Ú©Ø§Ø±Ø¨Ø± Ù…Ø´ØºÙˆÙ„ "${userActivity}" Ø§Ø³Øª. Ø¢ÛŒØ§ Ø§Ù„Ø§Ù† Ø²Ù…Ø§Ù† Ù…Ù†Ø§Ø³Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø§ÛŒÙ† Ø¹Ø§Ø¯Øª Ø§Ø³ØªØŸ ÛŒÚ© Ù¾Ø§Ø³Ø® Ú©ÙˆØªØ§Ù‡ Ø¨Ù„Ù‡/Ø®ÛŒØ± Ùˆ Ø¯Ø± ØµÙˆØ±Øª Ø¨Ù„Ù‡ØŒ ÛŒÚ© Ù…ØªÙ† ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ú©ÙˆØªØ§Ù‡ Ùˆ Ø¯ÙˆØ³ØªØ§Ù†Ù‡ Ø¨Ù‡ Ø²Ø¨Ø§Ù† ÙØ§Ø±Ø³ÛŒ Ø§Ø±Ø§Ø¦Ù‡ Ø¨Ø¯Ù‡. Ù¾Ø§Ø³Ø® Ø¯Ø± Ù‚Ø§Ù„Ø¨ JSON Ø¨Ø§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ "shouldRemind" (boolean) Ùˆ "reminderText" (stringØŒ ÙÙ‚Ø· Ø§Ú¯Ø± shouldRemind ØµØ­ÛŒØ­ Ø§Ø³Øª).`;
    try {
        const response: GenerateContentResponse = await ai.models.generateContent({ model: AI_MODEL_NAME, contents: prompt, config: { responseMimeType: "application/json" }});
        const parsed = parseJsonFromString<{shouldRemind: boolean; reminderText?: string}>(response.text);
        if(parsed && parsed.shouldRemind && parsed.reminderText) {
            return parsed.reminderText;
        }
        return null;
    } catch (e) {
        console.error("Error getting AI reminder:", e);
        return null;
    }
  };
  
  const handleSmartReminderClick = async (habit: Habit) => { 
    showToast(toPersianDigits(`Ø¯Ø± Ø­Ø§Ù„ Ø¨Ø±Ø±Ø³ÛŒ Ø¨Ù‡ØªØ±ÛŒÙ† Ø²Ù…Ø§Ù† Ø¨Ø±Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ø¹Ø§Ø¯Øª "${habit.title}"...`), 'info');
    const reminderText = await getAIWellnessReminder(habit);
    if (reminderText) {
        showToast(toPersianDigits(`ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯: ${reminderText}`), 'success');
    } else {
        showToast(toPersianDigits(`Ù‡ÙˆØ´ Ù…ØµÙ†ÙˆØ¹ÛŒ ØªØ´Ø®ÛŒØµ Ø¯Ø§Ø¯ Ø§Ù„Ø§Ù† Ø²Ù…Ø§Ù† Ù…Ù†Ø§Ø³Ø¨ÛŒ Ø¨Ø±Ø§ÛŒ ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ "${habit.title}" Ù†ÛŒØ³Øª. Ø¨Ø¹Ø¯Ø§Ù‹ Ø¨Ø±Ø±Ø³ÛŒ Ø®ÙˆØ§Ù‡Ø¯ Ø´Ø¯.`), 'info');
    }
  };

  const daysOfWeekMap: { [key: string]: string } = { Mon: "Ø¯", Tue: "Ø³", Wed: "Ú†", Thu: "Ù¾", Fri: "Ø¬", Sat: "Ø´", Sun: "ÛŒ" };
  const allDaysOfWeek: Array<NonNullable<NonNullable<Habit['customFrequencyDetails']>['daysOfWeek']>[0]> = ["Sat", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri"];

  return (
    <div className="page bg-habits-page">
      {toast && <ToastNotification message={toast.text} type={toast.type} isVisible={!!toast} onClose={() => setToast(null)} />}
      
      {addHabitModal.isOpen && (
        <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[100] p-4" onClick={() => setAddHabitModal(defaultAddHabitModalState)}>
          <div className="bg-white p-5 rounded-xl shadow-2xl w-full max-w-lg max-h-[90vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
            <div className="flex justify-between items-center mb-4 pb-3 border-b border-gray-200 flex-shrink-0">
              <h3 className="text-lg font-semibold text-gray-800">{toPersianDigits(addHabitModal.editingHabit ? "ÙˆÛŒØ±Ø§ÛŒØ´ Ø¹Ø§Ø¯Øª" : "Ø§ÙØ²ÙˆØ¯Ù† Ø¹Ø§Ø¯Øª Ø¬Ø¯ÛŒØ¯")}</h3>
              <button onClick={() => setAddHabitModal(defaultAddHabitModalState)} className="text-gray-500 hover:text-gray-700"><XMarkIcon className="w-6 h-6" /></button>
            </div>
            <form onSubmit={(e) => {e.preventDefault(); handleSaveHabit();}} className="space-y-3 flex-grow overflow-y-auto pr-1 modal-scroll-content text-sm">
              <div><label htmlFor="habitTitle" className="block text-xs font-medium text-gray-700 mb-1">Ø¹Ù†ÙˆØ§Ù† Ø¹Ø§Ø¯Øª*:</label><input type="text" id="habitTitle" value={toPersianDigits(addHabitModal.title)} onChange={e => setAddHabitModal(s => ({...s, title: e.target.value}))} required className="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" /></div>
              <div><label htmlFor="habitDesc" className="block text-xs font-medium text-gray-700 mb-1">ØªÙˆØ¶ÛŒØ­Ø§Øª (Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label><textarea id="habitDesc" value={toPersianDigits(addHabitModal.description)} onChange={e => setAddHabitModal(s => ({...s, description: e.target.value}))} rows={2} className="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500 resize-y" /></div>
              <div>
                <label htmlFor="habitFrequency" className="block text-xs font-medium text-gray-700 mb-1">ÙØ±Ú©Ø§Ù†Ø³*:</label>
                <select id="habitFrequency" value={addHabitModal.frequency} onChange={e => setAddHabitModal(s => ({...s, frequency: e.target.value as Habit['frequency']}))} className="w-full p-2 border border-gray-300 rounded-md bg-white focus:ring-indigo-500 focus:border-indigo-500">
                  <option value="daily">{toPersianDigits("Ø±ÙˆØ²Ø§Ù†Ù‡")}</option><option value="weekly">{toPersianDigits("Ù‡ÙØªÚ¯ÛŒ (Ø§Ù†ØªØ®Ø§Ø¨ Ø±ÙˆØ²Ù‡Ø§)")}</option><option value="custom">{toPersianDigits("Ø³ÙØ§Ø±Ø´ÛŒ (ØªÙˆØ¶ÛŒØ­ Ø¯Ø³ØªÛŒ)")}</option>
                </select>
              </div>
              {(addHabitModal.frequency === 'weekly' || addHabitModal.frequency === 'custom') && (
                <div>
                  <label className="block text-xs font-medium text-gray-700 mb-1">Ø±ÙˆØ²Ù‡Ø§ÛŒ Ù‡ÙØªÙ‡ (Ø¨Ø±Ø§ÛŒ Ù‡ÙØªÚ¯ÛŒ):</label>
                  <div className="flex flex-wrap gap-1.5">
                    {allDaysOfWeek.map(day => (
                      <button type="button" key={day} onClick={() => setAddHabitModal(s => ({...s, daysOfWeek: s.daysOfWeek.includes(day!) ? s.daysOfWeek.filter(d => d !== day) : [...s.daysOfWeek, day!]}))}
                              className={`px-2 py-1 text-[10px] border rounded-full ${addHabitModal.daysOfWeek.includes(day!) ? 'bg-purple-500 text-white border-purple-600' : 'bg-gray-100 text-gray-600 border-gray-300 hover:bg-gray-200'}`}>
                        {daysOfWeekMap[day!]}
                      </button>
                    ))}
                  </div>
                </div>
              )}
              <div><label htmlFor="habitTimeOfDay" className="block text-xs font-medium text-gray-700 mb-1">Ø²Ù…Ø§Ù† Ø±ÙˆØ²:</label>
                <select id="habitTimeOfDay" value={addHabitModal.timeOfDay} onChange={e => setAddHabitModal(s => ({...s, timeOfDay: e.target.value as Habit['timeOfDay']}))} className="w-full p-2 border border-gray-300 rounded-md bg-white focus:ring-indigo-500 focus:border-indigo-500">
                  <option value="any">{toPersianDigits("Ù‡Ø± Ø²Ù…Ø§Ù†")}</option><option value="morning">{toPersianDigits("ØµØ¨Ø­")}</option><option value="afternoon">{toPersianDigits("Ø¨Ø¹Ø¯ Ø§Ø² Ø¸Ù‡Ø±")}</option><option value="evening">{toPersianDigits("Ø¹ØµØ±")}</option>
                </select>
              </div>
              <div><label htmlFor="habitContext" className="block text-xs font-medium text-gray-700 mb-1">Ù…Ø­Ø±Ú© Ø²Ù…ÛŒÙ†Ù‡â€ŒØ§ÛŒ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label><input type="text" id="habitContext" value={toPersianDigits(addHabitModal.contextTrigger)} onChange={e => setAddHabitModal(s => ({...s, contextTrigger: e.target.value}))} className="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" placeholder={toPersianDigits("Ù…Ø«Ø§Ù„: Ø¨Ø¹Ø¯ Ø§Ø² ØµØ¨Ø­Ø§Ù†Ù‡")}/></div>
              <div><label htmlFor="habitGoal" className="block text-xs font-medium text-gray-700 mb-1">Ù‡Ø¯Ù Ù…Ø±ØªØ¨Ø· (Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label><input type="text" id="habitGoal" value={toPersianDigits(addHabitModal.relatedGoalId)} onChange={e => setAddHabitModal(s => ({...s, relatedGoalId: e.target.value}))} className="w-full p-2 border border-gray-300 rounded-md focus:ring-indigo-500 focus:border-indigo-500" placeholder={toPersianDigits("Ø´Ù†Ø§Ø³Ù‡ ÛŒØ§ Ø¹Ù†ÙˆØ§Ù† Ù‡Ø¯Ù")}/></div>
              <div className="flex justify-end space-x-2 space-x-reverse pt-3 border-t border-gray-100 flex-shrink-0"><button type="button" onClick={() => setAddHabitModal(defaultAddHabitModalState)} className="py-2 px-4 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md text-xs">Ø§Ù†ØµØ±Ø§Ù</button><button type="submit" className="py-2 px-4 bg-purple-600 hover:bg-purple-700 text-white rounded-md text-xs">Ø°Ø®ÛŒØ±Ù‡ Ø¹Ø§Ø¯Øª</button></div>
            </form>
          </div>
        </div>
      )}

      {logHabitModal.isOpen && logHabitModal.habitToLog && (
          <div className="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[101] p-4" onClick={() => setLogHabitModal(defaultLogHabitModalState)}>
              <div className="bg-white p-5 rounded-xl shadow-2xl w-full max-w-md max-h-[90vh] flex flex-col" onClick={e => e.stopPropagation()}>
                  <div className="flex justify-between items-center mb-4 pb-3 border-b border-gray-200 flex-shrink-0">
                      <h3 className="text-md font-semibold text-gray-800">{toPersianDigits(`Ø«Ø¨Øª Ú¯Ø²Ø§Ø±Ø´ Ø¨Ø±Ø§ÛŒ: ${logHabitModal.habitToLog.title}`)}</h3>
                      <button onClick={() => setLogHabitModal(defaultLogHabitModalState)} className="text-gray-500 hover:text-gray-700"><XMarkIcon className="w-6 h-6" /></button>
                  </div>
                  <form onSubmit={e => {e.preventDefault(); handleSaveHabitLog();}} className="space-y-3 flex-grow overflow-y-auto pr-1 modal-scroll-content text-sm">
                      <div><label className="block text-xs font-medium text-gray-700 mb-1">ØªØ§Ø±ÛŒØ®:</label><input type="date" value={logHabitModal.logDate} onChange={e => setLogHabitModal(s => ({...s, logDate: e.target.value}))} required className="w-full p-2 border border-gray-300 rounded-md"/></div>
                      <div className="flex items-center"><input type="checkbox" id="logCompleted" checked={logHabitModal.completed} onChange={e => setLogHabitModal(s=>({...s, completed: e.target.checked}))} className="h-4 w-4 text-purple-600 border-gray-300 rounded focus:ring-purple-500 mr-2"/><label htmlFor="logCompleted" className="text-xs text-gray-700">Ø¢ÛŒØ§ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯ØŸ</label></div>
                      <div><label className="block text-xs font-medium text-gray-700 mb-1">Ú©ÛŒÙÛŒØª Ø§Ù†Ø¬Ø§Ù… (Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label><select value={logHabitModal.quality} onChange={e => setLogHabitModal(s=>({...s, quality: e.target.value as HabitQuality}))} className="w-full p-2 border bg-white border-gray-300 rounded-md text-xs">{qualityOptions.map(opt => <option key={opt.value} value={opt.value}>{toPersianDigits(opt.label)}</option>)}</select></div>
                      <div><label className="block text-xs font-medium text-gray-700 mb-1">Ù…Ø¯Øª Ø²Ù…Ø§Ù† (Ø¯Ù‚ÛŒÙ‚Ù‡ØŒ Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label><input type="number" value={logHabitModal.durationMinutes} onChange={e => setLogHabitModal(s=>({...s, durationMinutes: e.target.value}))} className="w-full p-2 border border-gray-300 rounded-md text-xs" placeholder="Ù…Ø«Ø§Ù„: Û³Û°"/></div>
                      <div><label className="block text-xs font-medium text-gray-700 mb-1">Ø²Ù…ÛŒÙ†Ù‡ Ø§Ù†Ø¬Ø§Ù… (Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label><input type="text" value={toPersianDigits(logHabitModal.context)} onChange={e => setLogHabitModal(s=>({...s, context: e.target.value}))} className="w-full p-2 border border-gray-300 rounded-md text-xs" placeholder="Ù…Ø«Ø§Ù„: Ø¯Ø± Ø®Ø§Ù†Ù‡ØŒ Ø¨Ø¹Ø¯ Ø§Ø² Ú©Ø§Ø±"/></div>
                      <div className="grid grid-cols-2 gap-2">
                          <div><label className="block text-xs font-medium text-gray-700 mb-1">Ø§Ø­Ø³Ø§Ø³ Ù‚Ø¨Ù„ Ø§Ø² Ø§Ù†Ø¬Ø§Ù…:</label><select value={logHabitModal.emotionBefore} onChange={e => setLogHabitModal(s=>({...s, emotionBefore: e.target.value as HabitEmotion}))} className="w-full p-2 border bg-white border-gray-300 rounded-md text-xs">{emotionOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.emoji} {toPersianDigits(opt.label)}</option>)}</select></div>
                          <div><label className="block text-xs font-medium text-gray-700 mb-1">Ø§Ø­Ø³Ø§Ø³ Ø¨Ø¹Ø¯ Ø§Ø² Ø§Ù†Ø¬Ø§Ù…:</label><select value={logHabitModal.emotionAfter} onChange={e => setLogHabitModal(s=>({...s, emotionAfter: e.target.value as HabitEmotion}))} className="w-full p-2 border bg-white border-gray-300 rounded-md text-xs">{emotionOptions.map(opt => <option key={opt.value} value={opt.value}>{opt.emoji} {toPersianDigits(opt.label)}</option>)}</select></div>
                      </div>
                      <div><label className="block text-xs font-medium text-gray-700 mb-1">ÛŒØ§Ø¯Ø¯Ø§Ø´Øª (Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label><textarea value={toPersianDigits(logHabitModal.notes)} onChange={e => setLogHabitModal(s=>({...s, notes: e.target.value}))} rows={2} className="w-full p-2 border border-gray-300 rounded-md resize-y text-xs" /></div>
                      <div className="flex justify-end space-x-2 space-x-reverse pt-3 border-t border-gray-100 flex-shrink-0"><button type="button" onClick={() => setLogHabitModal(defaultLogHabitModalState)} className="py-2 px-3 text-gray-700 bg-gray-100 hover:bg-gray-200 rounded-md text-xs">Ø§Ù†ØµØ±Ø§Ù</button><button type="submit" className="py-2 px-3 bg-purple-600 hover:bg-purple-700 text-white rounded-md text-xs">Ø«Ø¨Øª Ú¯Ø²Ø§Ø±Ø´</button></div>
                  </form>
              </div>
          </div>
      )}

      <div className="flex items-center mb-6">
        <PageIcon className="w-7 h-7 text-purple-600 mr-3 rtl:ml-3 rtl:mr-0" />
        <h1 className="text-2xl font-semibold text-gray-800">{toPersianDigits("Ù…Ù‡Ù†Ø¯Ø³ÛŒ Ø¹Ø§Ø¯Øª")}</h1>
      </div>

      <CollapsibleSection title="Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ù‡ÙˆØ´Ù…Ù†Ø¯ Ø¹Ø§Ø¯Øª Ø§Ø² AI" icon={<LightbulbIcon className="text-yellow-500"/>} isOpen={true} onToggle={()=>{}} className="mb-6">
        <div className="p-2">
            <label htmlFor="userHabitContext" className="text-xs font-medium text-gray-700 mb-1 block">Ø²Ù…ÛŒÙ†Ù‡/Ù‡Ø¯Ù Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ø¹Ø§Ø¯Øª (Ø§Ø®ØªÛŒØ§Ø±ÛŒ):</label>
            <input type="text" id="userHabitContext" value={userHabitContext} onChange={e => setUserHabitContext(e.target.value)} placeholder="Ù…Ø«Ø§Ù„: Ú©Ø§Ù‡Ø´ Ø§Ø³ØªØ±Ø³ØŒ Ø§ÙØ²Ø§ÛŒØ´ ØªÙ…Ø±Ú©Ø²" className="w-full p-1.5 border border-gray-300 rounded-md text-xs mb-2"/>
            <button onClick={fetchAIHabitSuggestions} disabled={isLoadingAiSuggestions || !ai} className="w-full flex items-center justify-center text-xs py-2 px-3 bg-yellow-400 hover:bg-yellow-500 text-gray-800 rounded-md transition-colors disabled:opacity-60 mb-2">
                {isLoadingAiSuggestions ? <LoadingSpinner size="sm"/> : <AiIcon className="w-4 h-4 mr-1.5"/>} {toPersianDigits("Ø¯Ø±ÛŒØ§ÙØª Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯Ø§Øª Ø¬Ø¯ÛŒØ¯")}
            </button>
            {!ai && <p className="text-[10px] text-center text-gray-500">{toPersianDigits("(Ø³Ø±ÙˆÛŒØ³ AI Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª)")}</p>}
            {aiSuggestionError && <p className="text-xs text-red-500 bg-red-100 p-2 rounded-md text-center">{aiSuggestionError}</p>}
            {aiHabitSuggestions.length > 0 && (
                <div className="space-y-2 mt-2">
                    {aiHabitSuggestions.map((sugg, index) => (
                        <div key={index} className="p-3 bg-yellow-50 rounded-lg border border-yellow-200">
                            <h5 className="text-sm font-semibold text-yellow-700">{toPersianDigits(sugg.title)}</h5>
                            <p className="text-xs text-gray-600 mt-1">{toPersianDigits(sugg.description)}</p>
                            <p className="text-[10px] text-gray-500 mt-1">({toPersianDigits(sugg.aiRationale)})</p>
                            <button onClick={() => handleAcceptAISuggestion(sugg)} className="text-xs bg-green-500 hover:bg-green-600 text-white py-1 px-2 rounded-md mt-2">Ù¾Ø°ÛŒØ±ÙØªÙ† Ùˆ Ø§ÙØ²ÙˆØ¯Ù†</button>
                        </div>
                    ))}
                </div>
            )}
        </div>
      </CollapsibleSection>

      <div className="mb-6">
        <button onClick={() => handleOpenAddHabitModal()} className="w-full flex items-center justify-center bg-purple-600 hover:bg-purple-700 text-white font-medium py-2.5 px-4 rounded-lg text-sm shadow-md transition-colors">
          <PlusIcon className="w-5 h-5 mr-2 rtl:ml-2 rtl:mr-0" /> {toPersianDigits("Ø§ÙØ²ÙˆØ¯Ù† Ø¹Ø§Ø¯Øª Ø¬Ø¯ÛŒØ¯")}
        </button>
      </div>

      {habits.length === 0 ? ( 
         <div className="text-center py-8 bg-gray-100 rounded-xl shadow-inner">
            <PageIcon className="w-12 h-12 text-gray-400 mx-auto mb-3" />
            <p className="text-gray-600">{toPersianDigits("Ù‡Ù†ÙˆØ² Ø¹Ø§Ø¯ØªÛŒ Ø§ÛŒØ¬Ø§Ø¯ Ù†Ú©Ø±Ø¯Ù‡â€ŒØ§ÛŒØ¯.")}</p>
        </div>
       ) : (
        <div className="space-y-4">
          {habits.map(habit => (
            <div key={habit.id} className={`p-4 rounded-xl shadow-sm border ${habit.log.find(l=>l.date === new Date().toISOString().split('T')[0])?.completed ? 'bg-green-50 border-green-200' : 'bg-white border-gray-200'}`}>
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="text-md font-semibold text-purple-700">{toPersianDigits(habit.title)}</h4>
                  <p className="text-xs text-gray-500">{toPersianDigits(habit.frequency === 'daily' ? 'Ø±ÙˆØ²Ø§Ù†Ù‡' : `Ù‡ÙØªÚ¯ÛŒ (${(habit.customFrequencyDetails?.daysOfWeek || []).map(d => daysOfWeekMap[d]).join('ØŒ ')})`)} - {toPersianDigits(habit.timeOfDay === 'any' ? 'Ù‡Ø± Ø²Ù…Ø§Ù†' : habit.timeOfDay === 'morning' ? 'ØµØ¨Ø­' : habit.timeOfDay === 'afternoon' ? 'Ø¨Ø¹Ø¯ Ø§Ø² Ø¸Ù‡Ø±' : 'Ø¹ØµØ±' )}</p>
                </div>
                <div className="flex space-x-1 rtl:space-x-reverse">
                  <button onClick={() => handleOpenAddHabitModal(habit)} className="p-1 text-yellow-500 hover:bg-yellow-100 rounded-full"><PencilIcon className="w-4 h-4"/></button>
                  <button onClick={() => handleDeleteHabit(habit.id)} className="p-1 text-red-500 hover:bg-red-100 rounded-full"><TrashIcon className="w-4 h-4"/></button>
                </div>
              </div>
              <div className="flex items-center justify-between mt-2 text-xs">
                <span className="flex items-center text-orange-600"><FireIcon className="w-4 h-4 ml-1"/> {toPersianDigits(`Ø±Ø´ØªÙ‡: ${String(habit.streak)} Ø±ÙˆØ²`)}</span>
                <span className="flex items-center text-indigo-600"><StarIcon className="w-4 h-4 ml-1"/> {toPersianDigits(`Ø³Ø·Ø­: ${String(habit.level || 1)} (XP: ${String(habit.xp || 0)})`)}</span>
              </div>
              <div className="mt-3 pt-2 border-t border-gray-100 flex flex-col sm:flex-row gap-2">
                <button onClick={() => handleOpenLogHabitModal(habit, true)} className="flex-1 text-xs bg-green-500 hover:bg-green-600 text-white py-1.5 px-3 rounded-md flex items-center justify-center">
                  <CheckCircleIcon className="w-4 h-4 ml-1"/> {toPersianDigits("Ø«Ø¨Øª Ø§Ù†Ø¬Ø§Ù… Ø§Ù…Ø±ÙˆØ²")}
                </button>
                <button onClick={() => handleOpenLogHabitModal(habit, false)} className="flex-1 text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 py-1.5 px-3 rounded-md flex items-center justify-center">
                  <XCircleIcon className="w-4 h-4 ml-1"/> {toPersianDigits("Ø«Ø¨Øª Ø¹Ø¯Ù… Ø§Ù†Ø¬Ø§Ù…")}
                </button>
                {habit.reminderSettings?.enabled && (
                     <button onClick={() => handleSmartReminderClick(habit)} disabled={!ai} className="flex-1 text-xs bg-sky-500 hover:bg-sky-600 text-white py-1.5 px-3 rounded-md flex items-center justify-center disabled:opacity-60">
                        <BellIcon className="w-4 h-4 ml-1"/> {toPersianDigits("ÛŒØ§Ø¯Ø¢ÙˆØ±ÛŒ Ù‡ÙˆØ´Ù…Ù†Ø¯")}
                     </button>
                )}
              </div>
            </div>
          ))}
        </div>
      )}
    </div>
  );
};

export default HabitsPage;
```
    </content>
  </change>
</changes>```